<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQPushConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.9.2</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultMQPushConsumerImpl.java</span></div><h1>DefaultMQPushConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;

import org.apache.commons.lang3.StringUtils;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullCallback;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.listener.MessageListener;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.client.stat.ConsumerStatsManager;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageAccessor;
import org.apache.rocketmq.common.message.MessageConst;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.body.ConsumeStatus;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.body.ProcessQueueInfo;
import org.apache.rocketmq.common.protocol.body.QueueTimeSpan;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.protocol.route.BrokerData;
import org.apache.rocketmq.common.protocol.route.TopicRouteData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
    /**
     * Delay some time when exception occur
     */
<span class="fc" id="L86">    private long pullTimeDelayMillsWhenException = 3000;</span>
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
<span class="fc" id="L97">    private final InternalLogger log = ClientLogger.getLog();</span>
    private final DefaultMQPushConsumer defaultMQPushConsumer;
<span class="fc" id="L99">    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);</span>
<span class="fc" id="L100">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>
<span class="fc" id="L101">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L102">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>
    private final RPCHook rpcHook;
<span class="fc" id="L104">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>
    private MQClientInstance mQClientFactory;
    private PullAPIWrapper pullAPIWrapper;
<span class="fc" id="L107">    private volatile boolean pause = false;</span>
<span class="fc" id="L108">    private boolean consumeOrderly = false;</span>
    private MessageListener messageListenerInner;
    private OffsetStore offsetStore;
    private ConsumeMessageService consumeMessageService;
<span class="fc" id="L112">    private long queueFlowControlTimes = 0;</span>
<span class="fc" id="L113">    private long queueMaxSpanFlowControlTimes = 0;</span>

<span class="fc" id="L115">    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {</span>
<span class="fc" id="L116">        this.defaultMQPushConsumer = defaultMQPushConsumer;</span>
<span class="fc" id="L117">        this.rpcHook = rpcHook;</span>
<span class="fc" id="L118">        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();</span>
<span class="fc" id="L119">    }</span>

    public void registerFilterMessageHook(final FilterMessageHook hook) {
<span class="nc" id="L122">        this.filterMessageHookList.add(hook);</span>
<span class="nc" id="L123">        log.info(&quot;register FilterMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L124">    }</span>

    public boolean hasHook() {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        return !this.consumeMessageHookList.isEmpty();</span>
    }

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="fc" id="L131">        this.consumeMessageHookList.add(hook);</span>
<span class="fc" id="L132">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="fc" id="L133">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="fc" id="L139">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L140">                } catch (Throwable e) {</span>
<span class="fc" id="L141">                }</span>
<span class="fc" id="L142">            }</span>
        }
<span class="fc" id="L144">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="fc" id="L150">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L151">                } catch (Throwable e) {</span>
<span class="fc" id="L152">                }</span>
<span class="fc" id="L153">            }</span>
        }
<span class="fc" id="L155">    }</span>

    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L158">        createTopic(key, newTopic, queueNum, 0);</span>
<span class="nc" id="L159">    }</span>

    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L162">        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag);</span>
<span class="nc" id="L163">    }</span>

    public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L166">        Set&lt;MessageQueue&gt; result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L168">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L169">            result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
        }

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L173">            throw new MQClientException(&quot;The topic[&quot; + topic + &quot;] not exist&quot;, null);</span>
        }

<span class="nc" id="L176">        return parseSubscribeMessageQueues(result);</span>
    }

    public Set&lt;MessageQueue&gt; parseSubscribeMessageQueues(Set&lt;MessageQueue&gt; messageQueueList) {
<span class="nc" id="L180">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (MessageQueue queue : messageQueueList) {</span>
<span class="nc" id="L182">            String userTopic = NamespaceUtil.withoutNamespace(queue.getTopic(), this.defaultMQPushConsumer.getNamespace());</span>
<span class="nc" id="L183">            resultQueues.add(new MessageQueue(userTopic, queue.getBrokerName(), queue.getQueueId()));</span>
<span class="nc" id="L184">        }</span>

<span class="nc" id="L186">        return resultQueues;</span>
    }

    public DefaultMQPushConsumer getDefaultMQPushConsumer() {
<span class="fc" id="L190">        return defaultMQPushConsumer;</span>
    }

    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L194">        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);</span>
    }

    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L198">        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span>
    }

    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L202">        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);</span>
    }

    public OffsetStore getOffsetStore() {
<span class="fc" id="L206">        return offsetStore;</span>
    }

    public void setOffsetStore(OffsetStore offsetStore) {
<span class="nc" id="L210">        this.offsetStore = offsetStore;</span>
<span class="nc" id="L211">    }</span>

    public void pullMessage(final PullRequest pullRequest) {
<span class="fc" id="L214">        final ProcessQueue processQueue = pullRequest.getProcessQueue();</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (processQueue.isDropped()) {</span>
<span class="nc" id="L216">            log.info(&quot;the pull request[{}] is dropped.&quot;, pullRequest.toString());</span>
<span class="nc" id="L217">            return;</span>
        }

<span class="fc" id="L220">        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span>

        try {
<span class="fc" id="L223">            this.makeSureStateOK();</span>
<span class="nc" id="L224">        } catch (MQClientException e) {</span>
<span class="nc" id="L225">            log.warn(&quot;pullMessage exception, consumer state not ok&quot;, e);</span>
<span class="nc" id="L226">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L227">            return;</span>
<span class="fc" id="L228">        }</span>

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (this.isPause()) {</span>
<span class="nc" id="L231">            log.warn(&quot;consumer was paused, execute pull request later. instanceName={}, group={}&quot;, this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L232">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span>
<span class="nc" id="L233">            return;</span>
        }

<span class="fc" id="L236">        long cachedMessageCount = processQueue.getMsgCount().get();</span>
<span class="fc" id="L237">        long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span>

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) {</span>
<span class="nc" id="L240">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L242">                log.warn(</span>
                    &quot;the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L244">                    this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L246">            return;</span>
        }

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {</span>
<span class="nc" id="L250">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L252">                log.warn(</span>
                    &quot;the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L254">                    this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L256">            return;</span>
        }

<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (!this.consumeOrderly) {</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {</span>
<span class="nc" id="L261">                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L263">                    log.warn(</span>
                        &quot;the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L265">                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span>
<span class="nc" id="L266">                        pullRequest, queueMaxSpanFlowControlTimes);</span>
                }
<span class="nc" id="L268">                return;</span>
            }
        } else {
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            if (processQueue.isLocked()) {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">                if (!pullRequest.isPreviouslyLocked()) {</span>
<span class="fc" id="L273">                    long offset = -1L;</span>
                    try {
<span class="fc" id="L275">                        offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());</span>
<span class="nc" id="L276">                    } catch (Exception e) {</span>
<span class="nc" id="L277">                        this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L278">                        log.error(&quot;Failed to compute pull offset, pullResult: {}&quot;, pullRequest, e);</span>
<span class="nc" id="L279">                        return;</span>
<span class="fc" id="L280">                    }</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                    boolean brokerBusy = offset &lt; pullRequest.getNextOffset();</span>
<span class="fc" id="L282">                    log.info(&quot;the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}&quot;,</span>
<span class="fc" id="L283">                        pullRequest, offset, brokerBusy);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    if (brokerBusy) {</span>
<span class="fc" id="L285">                        log.info(&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}&quot;,</span>
<span class="fc" id="L286">                            pullRequest, offset);</span>
                    }

<span class="fc" id="L289">                    pullRequest.setPreviouslyLocked(true);</span>
<span class="fc" id="L290">                    pullRequest.setNextOffset(offset);</span>
<span class="fc" id="L291">                }</span>
            } else {
<span class="nc" id="L293">                this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L294">                log.info(&quot;pull message later because not locked in broker, {}&quot;, pullRequest);</span>
<span class="nc" id="L295">                return;</span>
            }
        }

<span class="fc" id="L299">        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (null == subscriptionData) {</span>
<span class="nc" id="L301">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L302">            log.warn(&quot;find the consumer's subscription failed, {}&quot;, pullRequest);</span>
<span class="nc" id="L303">            return;</span>
        }

<span class="fc" id="L306">        final long beginTimestamp = System.currentTimeMillis();</span>

<span class="fc" id="L308">        PullCallback pullCallback = new PullCallback() {</span>
            @Override
            public void onSuccess(PullResult pullResult) {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                if (pullResult != null) {</span>
<span class="fc" id="L312">                    pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span>
                        subscriptionData);

<span class="pc bpc" id="L315" title="3 of 4 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="fc" id="L317">                            long prevRequestOffset = pullRequest.getNextOffset();</span>
<span class="fc" id="L318">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>
<span class="fc" id="L319">                            long pullRT = System.currentTimeMillis() - beginTimestamp;</span>
<span class="fc" id="L320">                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span>
<span class="fc" id="L321">                                pullRequest.getMessageQueue().getTopic(), pullRT);</span>

<span class="fc" id="L323">                            long firstMsgOffset = Long.MAX_VALUE;</span>
<span class="pc bpc" id="L324" title="2 of 4 branches missed.">                            if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {</span>
<span class="nc" id="L325">                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                            } else {
<span class="fc" id="L327">                                firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();</span>

<span class="fc" id="L329">                                DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span>
<span class="fc" id="L330">                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span>

<span class="fc" id="L332">                                boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="fc" id="L333">                                DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(</span>
<span class="fc" id="L334">                                    pullResult.getMsgFoundList(),</span>
                                    processQueue,
<span class="fc" id="L336">                                    pullRequest.getMessageQueue(),</span>
                                    dispatchToConsume);

<span class="pc bpc" id="L339" title="1 of 2 branches missed.">                                if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) {</span>
<span class="fc" id="L340">                                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,</span>
<span class="fc" id="L341">                                        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span>
                                } else {
<span class="nc" id="L343">                                    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                                }
                            }

<span class="pc bpc" id="L347" title="2 of 4 branches missed.">                            if (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span>
                                || firstMsgOffset &lt; prevRequestOffset) {
<span class="fc" id="L349">                                log.warn(</span>
                                    &quot;[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}&quot;,
<span class="fc" id="L351">                                    pullResult.getNextBeginOffset(),</span>
<span class="fc" id="L352">                                    firstMsgOffset,</span>
<span class="fc" id="L353">                                    prevRequestOffset);</span>
                            }

                            break;
                        case NO_NEW_MSG:
                        case NO_MATCHED_MSG:
<span class="nc" id="L359">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L361">                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);</span>

<span class="nc" id="L363">                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L364">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L366">                            log.warn(&quot;the pull request offset illegal, {} {}&quot;,</span>
<span class="nc" id="L367">                                pullRequest.toString(), pullResult.toString());</span>
<span class="nc" id="L368">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L370">                            pullRequest.getProcessQueue().setDropped(true);</span>
<span class="nc" id="L371">                            DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {</span>

                                @Override
                                public void run() {
                                    try {
<span class="nc" id="L376">                                        DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span>
<span class="nc" id="L377">                                            pullRequest.getNextOffset(), false);</span>

<span class="nc" id="L379">                                        DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());</span>

<span class="nc" id="L381">                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span>

<span class="nc" id="L383">                                        log.warn(&quot;fix the pull request offset, {}&quot;, pullRequest);</span>
<span class="nc" id="L384">                                    } catch (Throwable e) {</span>
<span class="nc" id="L385">                                        log.error(&quot;executeTaskLater Exception&quot;, e);</span>
<span class="nc" id="L386">                                    }</span>
<span class="nc" id="L387">                                }</span>
                            }, 10000);
<span class="nc" id="L389">                            break;</span>
                        default:
                            break;
                    }
                }
<span class="fc" id="L394">            }</span>

            @Override
            public void onException(Throwable e) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">                if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {</span>
<span class="nc" id="L399">                    log.warn(&quot;execute the pull request exception&quot;, e);</span>
                }

<span class="nc" id="L402">                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L403">            }</span>
        };

<span class="fc" id="L406">        boolean commitOffsetEnable = false;</span>
<span class="fc" id="L407">        long commitOffsetValue = 0L;</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="fc" id="L409">            commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (commitOffsetValue &gt; 0) {</span>
<span class="nc" id="L411">                commitOffsetEnable = true;</span>
            }
        }

<span class="fc" id="L415">        String subExpression = null;</span>
<span class="fc" id="L416">        boolean classFilter = false;</span>
<span class="fc" id="L417">        SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (sd != null) {</span>
<span class="pc bpc" id="L419" title="3 of 4 branches missed.">            if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) {</span>
<span class="nc" id="L420">                subExpression = sd.getSubString();</span>
            }

<span class="fc" id="L423">            classFilter = sd.isClassFilterMode();</span>
        }

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        int sysFlag = PullSysFlag.buildSysFlag(</span>
            commitOffsetEnable, // commitOffset
            true, // suspend
            subExpression != null, // subscription
            classFilter // class filter
        );
        try {
<span class="fc" id="L433">            this.pullAPIWrapper.pullKernelImpl(</span>
<span class="fc" id="L434">                pullRequest.getMessageQueue(),</span>
                subExpression,
<span class="fc" id="L436">                subscriptionData.getExpressionType(),</span>
<span class="fc" id="L437">                subscriptionData.getSubVersion(),</span>
<span class="fc" id="L438">                pullRequest.getNextOffset(),</span>
<span class="fc" id="L439">                this.defaultMQPushConsumer.getPullBatchSize(),</span>
                sysFlag,
                commitOffsetValue,
                BROKER_SUSPEND_MAX_TIME_MILLIS,
                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,
                CommunicationMode.ASYNC,
                pullCallback
            );
<span class="fc" id="L447">        } catch (Exception e) {</span>
<span class="fc" id="L448">            log.error(&quot;pullKernelImpl exception&quot;, e);</span>
<span class="fc" id="L449">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="fc" id="L450">        }</span>
<span class="fc" id="L451">    }</span>

    private void makeSureStateOK() throws MQClientException {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L455">            throw new MQClientException(&quot;The consumer service state not OK, &quot;</span>
                + this.serviceState
<span class="nc" id="L457">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                null);
        }
<span class="fc" id="L460">    }</span>

    private void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {
<span class="fc" id="L463">        this.mQClientFactory.getPullMessageService().executePullRequestLater(pullRequest, timeDelay);</span>
<span class="fc" id="L464">    }</span>

    public boolean isPause() {
<span class="fc" id="L467">        return pause;</span>
    }

    public void setPause(boolean pause) {
<span class="nc" id="L471">        this.pause = pause;</span>
<span class="nc" id="L472">    }</span>

    public ConsumerStatsManager getConsumerStatsManager() {
<span class="fc" id="L475">        return this.mQClientFactory.getConsumerStatsManager();</span>
    }

    public void executePullRequestImmediately(final PullRequest pullRequest) {
<span class="nc" id="L479">        this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L480">    }</span>

    private void correctTagsOffset(final PullRequest pullRequest) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {</span>
<span class="nc" id="L484">            this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);</span>
        }
<span class="nc" id="L486">    }</span>

    public void executeTaskLater(final Runnable r, final long timeDelay) {
<span class="nc" id="L489">        this.mQClientFactory.getPullMessageService().executeTaskLater(r, timeDelay);</span>
<span class="nc" id="L490">    }</span>

    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L494">        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);</span>
    }

    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,
        InterruptedException {
<span class="nc" id="L499">        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);</span>
    }

    public void registerMessageListener(MessageListener messageListener) {
<span class="fc" id="L503">        this.messageListenerInner = messageListener;</span>
<span class="fc" id="L504">    }</span>

    public void resume() {
<span class="nc" id="L507">        this.pause = false;</span>
<span class="nc" id="L508">        doRebalance();</span>
<span class="nc" id="L509">        log.info(&quot;resume this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L510">    }</span>

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">            String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)</span>
<span class="pc" id="L516">                : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span>
<span class="fc" id="L517">            this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span>
<span class="fc" id="L518">                this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());</span>
<span class="nc" id="L519">        } catch (Exception e) {</span>
<span class="nc" id="L520">            log.error(&quot;sendMessageBack Exception, &quot; + this.defaultMQPushConsumer.getConsumerGroup(), e);</span>

<span class="nc" id="L522">            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span>

<span class="nc" id="L524">            String originMsgId = MessageAccessor.getOriginMessageId(msg);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span>

<span class="nc" id="L527">            newMsg.setFlag(msg.getFlag());</span>
<span class="nc" id="L528">            MessageAccessor.setProperties(newMsg, msg.getProperties());</span>
<span class="nc" id="L529">            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span>
<span class="nc" id="L530">            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));</span>
<span class="nc" id="L531">            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span>
<span class="nc" id="L532">            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span>
<span class="nc" id="L533">            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());</span>

<span class="nc" id="L535">            this.mQClientFactory.getDefaultMQProducer().send(newMsg);</span>
        } finally {
<span class="fc" id="L537">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
        }
<span class="fc" id="L539">    }</span>

    private int getMaxReconsumeTimes() {
        // default reconsume times: 16
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {</span>
<span class="fc" id="L544">            return 16;</span>
        } else {
<span class="nc" id="L546">            return this.defaultMQPushConsumer.getMaxReconsumeTimes();</span>
        }
    }

    public void shutdown() {
<span class="nc" id="L551">        shutdown(0);</span>
<span class="nc" id="L552">    }</span>

    public synchronized void shutdown(long awaitTerminateMillis) {
<span class="pc bpc" id="L555" title="2 of 4 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L557">                break;</span>
            case RUNNING:
<span class="fc" id="L559">                this.consumeMessageService.shutdown(awaitTerminateMillis);</span>
<span class="fc" id="L560">                this.persistConsumerOffset();</span>
<span class="fc" id="L561">                this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L562">                this.mQClientFactory.shutdown();</span>
<span class="fc" id="L563">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L564">                this.rebalanceImpl.destroy();</span>
<span class="fc" id="L565">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="fc" id="L566">                break;</span>
            case SHUTDOWN_ALREADY:
<span class="fc" id="L568">                break;</span>
            default:
                break;
        }
<span class="fc" id="L572">    }</span>

    public synchronized void start() throws MQClientException {
<span class="pc bpc" id="L575" title="2 of 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="fc" id="L577">                log.info(&quot;the consumer [{}] start beginning. messageModel={}, isUnitMode={}&quot;, this.defaultMQPushConsumer.getConsumerGroup(),</span>
<span class="fc" id="L578">                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());</span>
<span class="fc" id="L579">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="fc" id="L581">                this.checkConfig();</span>

<span class="fc" id="L583">                this.copySubscription();</span>

<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="fc" id="L586">                    this.defaultMQPushConsumer.changeInstanceNameToPID();</span>
                }

<span class="fc" id="L589">                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);</span>

<span class="fc" id="L591">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L592">                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());</span>
<span class="fc" id="L593">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span>
<span class="fc" id="L594">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>

<span class="fc" id="L596">                this.pullAPIWrapper = new PullAPIWrapper(</span>
                    mQClientFactory,
<span class="fc" id="L598">                    this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="fc" id="L599">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>

<span class="fc bfc" id="L601" title="All 2 branches covered.">                if (this.defaultMQPushConsumer.getOffsetStore() != null) {</span>
<span class="fc" id="L602">                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();</span>
                } else {
<span class="pc bpc" id="L604" title="2 of 3 branches missed.">                    switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                        case BROADCASTING:
<span class="nc" id="L606">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L607">                            break;</span>
                        case CLUSTERING:
<span class="fc" id="L609">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L610">                            break;</span>
                        default:
                            break;
                    }
<span class="fc" id="L614">                    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);</span>
                }
<span class="fc" id="L616">                this.offsetStore.load();</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {</span>
<span class="nc" id="L619">                    this.consumeOrderly = true;</span>
<span class="nc" id="L620">                    this.consumeMessageService =</span>
<span class="nc" id="L621">                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">                } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {</span>
<span class="fc" id="L623">                    this.consumeOrderly = false;</span>
<span class="fc" id="L624">                    this.consumeMessageService =</span>
<span class="fc" id="L625">                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span>
                }

<span class="fc" id="L628">                this.consumeMessageService.start();</span>

<span class="fc" id="L630">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">                if (!registerOK) {</span>
<span class="nc" id="L632">                    this.serviceState = ServiceState.CREATE_JUST;</span>
<span class="nc" id="L633">                    this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());</span>
<span class="nc" id="L634">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()</span>
<span class="nc" id="L635">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                        null);
                }

<span class="fc" id="L639">                mQClientFactory.start();</span>
<span class="fc" id="L640">                log.info(&quot;the consumer [{}] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L641">                this.serviceState = ServiceState.RUNNING;</span>
<span class="fc" id="L642">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L646">                throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L648">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }

<span class="fc" id="L654">        this.updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
<span class="fc" id="L655">        this.mQClientFactory.checkClientInBroker();</span>
<span class="fc" id="L656">        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="fc" id="L657">        this.mQClientFactory.rebalanceImmediately();</span>
<span class="fc" id="L658">    }</span>

    private void checkConfig() throws MQClientException {
<span class="fc" id="L661">        Validators.checkGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>

<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumerGroup()) {</span>
<span class="nc" id="L664">            throw new MQClientException(</span>
                &quot;consumerGroup is null&quot;
<span class="nc" id="L666">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L670" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L671">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L675">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L679" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L680">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L682">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L686" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumeFromWhere()) {</span>
<span class="nc" id="L687">            throw new MQClientException(</span>
                &quot;consumeFromWhere is null&quot;
<span class="nc" id="L689">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L693">        Date dt = UtilAll.parseDate(this.defaultMQPushConsumer.getConsumeTimestamp(), UtilAll.YYYYMMDDHHMMSS);</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (null == dt) {</span>
<span class="nc" id="L695">            throw new MQClientException(</span>
                &quot;consumeTimestamp is invalid, the valid format is yyyyMMddHHmmss,but received &quot;
<span class="nc" id="L697">                    + this.defaultMQPushConsumer.getConsumeTimestamp()</span>
<span class="nc" id="L698">                    + &quot; &quot; + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL), null);</span>
        }

        // allocateMessageQueueStrategy
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L703">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L705">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // subscription
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getSubscription()) {</span>
<span class="nc" id="L711">            throw new MQClientException(</span>
                &quot;subscription is null&quot;
<span class="nc" id="L713">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // messageListener
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageListener()) {</span>
<span class="nc" id="L719">            throw new MQClientException(</span>
                &quot;messageListener is null&quot;
<span class="nc" id="L721">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L725">        boolean orderly = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerOrderly;</span>
<span class="fc" id="L726">        boolean concurrently = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerConcurrently;</span>
<span class="pc bpc" id="L727" title="2 of 4 branches missed.">        if (!orderly &amp;&amp; !concurrently) {</span>
<span class="nc" id="L728">            throw new MQClientException(</span>
                &quot;messageListener must be instanceof MessageListenerOrderly or MessageListenerConcurrently&quot;
<span class="nc" id="L730">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &lt; 1</span>
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeThreadMin() &gt; 1000) {</span>
<span class="nc" id="L737">            throw new MQClientException(</span>
                &quot;consumeThreadMin Out of range [1, 1000]&quot;
<span class="nc" id="L739">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMax
<span class="pc bpc" id="L744" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMax() &lt; 1 || this.defaultMQPushConsumer.getConsumeThreadMax() &gt; 1000) {</span>
<span class="nc" id="L745">            throw new MQClientException(</span>
                &quot;consumeThreadMax Out of range [1, 1000]&quot;
<span class="nc" id="L747">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin can't be larger than consumeThreadMax
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &gt; this.defaultMQPushConsumer.getConsumeThreadMax()) {</span>
<span class="fc" id="L753">            throw new MQClientException(</span>
<span class="fc" id="L754">                &quot;consumeThreadMin (&quot; + this.defaultMQPushConsumer.getConsumeThreadMin() + &quot;) &quot;</span>
<span class="fc" id="L755">                    + &quot;is larger than consumeThreadMax (&quot; + this.defaultMQPushConsumer.getConsumeThreadMax() + &quot;)&quot;,</span>
                null);
        }

        // consumeConcurrentlyMaxSpan
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &lt; 1</span>
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &gt; 65535) {</span>
<span class="nc" id="L762">            throw new MQClientException(</span>
                &quot;consumeConcurrentlyMaxSpan Out of range [1, 65535]&quot;
<span class="nc" id="L764">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForQueue
<span class="pc bpc" id="L769" title="1 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForQueue() &gt; 65535) {</span>
<span class="fc" id="L770">            throw new MQClientException(</span>
                &quot;pullThresholdForQueue Out of range [1, 65535]&quot;
<span class="fc" id="L772">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForTopic
<span class="fc bfc" id="L777" title="All 2 branches covered.">        if (this.defaultMQPushConsumer.getPullThresholdForTopic() != -1) {</span>
<span class="pc bpc" id="L778" title="2 of 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForTopic() &gt; 6553500) {</span>
<span class="fc" id="L779">                throw new MQClientException(</span>
                    &quot;pullThresholdForTopic Out of range [1, 6553500]&quot;
<span class="fc" id="L781">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullThresholdSizeForQueue
<span class="pc bpc" id="L787" title="1 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &gt; 1024) {</span>
<span class="fc" id="L788">            throw new MQClientException(</span>
                &quot;pullThresholdSizeForQueue Out of range [1, 1024]&quot;
<span class="fc" id="L790">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() != -1) {</span>
            // pullThresholdSizeForTopic
<span class="pc bpc" id="L796" title="2 of 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &gt; 102400) {</span>
<span class="fc" id="L797">                throw new MQClientException(</span>
                    &quot;pullThresholdSizeForTopic Out of range [1, 102400]&quot;
<span class="fc" id="L799">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullInterval
<span class="pc bpc" id="L805" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullInterval() &lt; 0 || this.defaultMQPushConsumer.getPullInterval() &gt; 65535) {</span>
<span class="nc" id="L806">            throw new MQClientException(</span>
                &quot;pullInterval Out of range [0, 65535]&quot;
<span class="nc" id="L808">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeMessageBatchMaxSize
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &lt; 1</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &gt; 1024) {</span>
<span class="nc" id="L815">            throw new MQClientException(</span>
                &quot;consumeMessageBatchMaxSize Out of range [1, 1024]&quot;
<span class="nc" id="L817">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullBatchSize
<span class="pc bpc" id="L822" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getPullBatchSize() &lt; 1 || this.defaultMQPushConsumer.getPullBatchSize() &gt; 1024) {</span>
<span class="nc" id="L823">            throw new MQClientException(</span>
                &quot;pullBatchSize Out of range [1, 1024]&quot;
<span class="nc" id="L825">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="fc" id="L828">    }</span>

    private void copySubscription() throws MQClientException {
        try {
<span class="fc" id="L832">            Map&lt;String, String&gt; sub = this.defaultMQPushConsumer.getSubscription();</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">            if (sub != null) {</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                for (final Map.Entry&lt;String, String&gt; entry : sub.entrySet()) {</span>
<span class="nc" id="L835">                    final String topic = entry.getKey();</span>
<span class="nc" id="L836">                    final String subString = entry.getValue();</span>
<span class="nc" id="L837">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subString);</span>
<span class="nc" id="L838">                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L839">                }</span>
            }

<span class="pc bpc" id="L842" title="1 of 2 branches missed.">            if (null == this.messageListenerInner) {</span>
<span class="nc" id="L843">                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();</span>
            }

<span class="pc bpc" id="L846" title="2 of 3 branches missed.">            switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="nc" id="L848">                    break;</span>
                case CLUSTERING:
<span class="fc" id="L850">                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="fc" id="L851">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(retryTopic, SubscriptionData.SUB_ALL);</span>
<span class="fc" id="L852">                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span>
<span class="fc" id="L853">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L857">        } catch (Exception e) {</span>
<span class="nc" id="L858">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="fc" id="L859">        }</span>
<span class="fc" id="L860">    }</span>

    public MessageListener getMessageListenerInner() {
<span class="fc" id="L863">        return messageListenerInner;</span>
    }

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="fc" id="L867">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="pc bpc" id="L868" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="fc" id="L870">                final String topic = entry.getKey();</span>
<span class="fc" id="L871">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="fc" id="L872">            }</span>
        }
<span class="fc" id="L874">    }</span>

    public ConcurrentMap&lt;String, SubscriptionData&gt; getSubscriptionInner() {
<span class="fc" id="L877">        return this.rebalanceImpl.getSubscriptionInner();</span>
    }

    public void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="fc" id="L882">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);</span>
<span class="fc" id="L883">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L885">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L887">        } catch (Exception e) {</span>
<span class="nc" id="L888">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="fc" id="L889">        }</span>
<span class="fc" id="L890">    }</span>

    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
        try {
<span class="nc" id="L894">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, &quot;*&quot;);</span>
<span class="nc" id="L895">            subscriptionData.setSubString(fullClassName);</span>
<span class="nc" id="L896">            subscriptionData.setClassFilterMode(true);</span>
<span class="nc" id="L897">            subscriptionData.setFilterClassSource(filterClassSource);</span>
<span class="nc" id="L898">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L900">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }

<span class="nc" id="L903">        } catch (Exception e) {</span>
<span class="nc" id="L904">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L905">        }</span>
<span class="nc" id="L906">    }</span>

    public void subscribe(final String topic, final MessageSelector messageSelector) throws MQClientException {
        try {
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (messageSelector == null) {</span>
<span class="nc" id="L911">                subscribe(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L912">                return;</span>
            }

<span class="nc" id="L915">            SubscriptionData subscriptionData = FilterAPI.build(topic,</span>
<span class="nc" id="L916">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>

<span class="nc" id="L918">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L920">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L922">        } catch (Exception e) {</span>
<span class="nc" id="L923">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L924">        }</span>
<span class="nc" id="L925">    }</span>

    public void suspend() {
<span class="nc" id="L928">        this.pause = true;</span>
<span class="nc" id="L929">        log.info(&quot;suspend this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L930">    }</span>

    public void unsubscribe(String topic) {
<span class="nc" id="L933">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L934">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L937">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L938">    }</span>

    public void updateCorePoolSize(int corePoolSize) {
<span class="nc" id="L941">        this.consumeMessageService.updateCorePoolSize(corePoolSize);</span>
<span class="nc" id="L942">    }</span>

    public MessageExt viewMessage(String msgId)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L946">        return this.mQClientFactory.getMQAdminImpl().viewMessage(msgId);</span>
    }

    public RebalanceImpl getRebalanceImpl() {
<span class="fc" id="L950">        return rebalanceImpl;</span>
    }

    public boolean isConsumeOrderly() {
<span class="fc" id="L954">        return consumeOrderly;</span>
    }

    public void setConsumeOrderly(boolean consumeOrderly) {
<span class="fc" id="L958">        this.consumeOrderly = consumeOrderly;</span>
<span class="fc" id="L959">    }</span>

    public void resetOffsetByTimeStamp(long timeStamp)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc bnc" id="L963" title="All 2 branches missed.">        for (String topic : rebalanceImpl.getSubscriptionInner().keySet()) {</span>
<span class="nc" id="L964">            Set&lt;MessageQueue&gt; mqs = rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc" id="L965">            Map&lt;MessageQueue, Long&gt; offsetTable = new HashMap&lt;MessageQueue, Long&gt;();</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (mqs != null) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                for (MessageQueue mq : mqs) {</span>
<span class="nc" id="L968">                    long offset = searchOffset(mq, timeStamp);</span>
<span class="nc" id="L969">                    offsetTable.put(mq, offset);</span>
<span class="nc" id="L970">                }</span>
<span class="nc" id="L971">                this.mQClientFactory.resetOffset(topic, groupName(), offsetTable);</span>
            }
<span class="nc" id="L973">        }</span>
<span class="nc" id="L974">    }</span>

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L977">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    @Override
    public String groupName() {
<span class="fc" id="L982">        return this.defaultMQPushConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="fc" id="L987">        return this.defaultMQPushConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="fc" id="L992">        return ConsumeType.CONSUME_PASSIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="fc" id="L997">        return this.defaultMQPushConsumer.getConsumeFromWhere();</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="fc" id="L1002">        Set&lt;SubscriptionData&gt; subSet = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="fc" id="L1004">        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());</span>

<span class="fc" id="L1006">        return subSet;</span>
    }

    @Override
    public void doRebalance() {
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (!this.pause) {</span>
<span class="fc" id="L1012">            this.rebalanceImpl.doRebalance(this.isConsumeOrderly());</span>
        }
<span class="fc" id="L1014">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="fc" id="L1019">            this.makeSureStateOK();</span>
<span class="fc" id="L1020">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="fc" id="L1021">            Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="fc" id="L1022">            mqs.addAll(allocateMq);</span>

<span class="fc" id="L1024">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L1025">        } catch (Exception e) {</span>
<span class="nc" id="L1026">            log.error(&quot;group: &quot; + this.defaultMQPushConsumer.getConsumerGroup() + &quot; persistConsumerOffset exception&quot;, e);</span>
<span class="fc" id="L1027">        }</span>
<span class="fc" id="L1028">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="fc" id="L1032">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">            if (subTable.containsKey(topic)) {</span>
<span class="fc" id="L1035">                this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);</span>
            }
        }
<span class="fc" id="L1038">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L1042">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L1049">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="fc" id="L1054">        return this.defaultMQPushConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="fc" id="L1059">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="fc" id="L1061">        Properties prop = MixAll.object2Properties(this.defaultMQPushConsumer);</span>

<span class="fc" id="L1063">        prop.put(ConsumerRunningInfo.PROP_CONSUME_ORDERLY, String.valueOf(this.consumeOrderly));</span>
<span class="fc" id="L1064">        prop.put(ConsumerRunningInfo.PROP_THREADPOOL_CORE_SIZE, String.valueOf(this.consumeMessageService.getCorePoolSize()));</span>
<span class="fc" id="L1065">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>

<span class="fc" id="L1067">        info.setProperties(prop);</span>

<span class="fc" id="L1069">        Set&lt;SubscriptionData&gt; subSet = this.subscriptions();</span>
<span class="fc" id="L1070">        info.getSubscriptionSet().addAll(subSet);</span>

<span class="fc" id="L1072">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.rebalanceImpl.getProcessQueueTable().entrySet().iterator();</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1074">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1075">            MessageQueue mq = next.getKey();</span>
<span class="nc" id="L1076">            ProcessQueue pq = next.getValue();</span>

<span class="nc" id="L1078">            ProcessQueueInfo pqinfo = new ProcessQueueInfo();</span>
<span class="nc" id="L1079">            pqinfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));</span>
<span class="nc" id="L1080">            pq.fillProcessQueueInfo(pqinfo);</span>
<span class="nc" id="L1081">            info.getMqTable().put(mq, pqinfo);</span>
<span class="nc" id="L1082">        }</span>

<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">        for (SubscriptionData sd : subSet) {</span>
<span class="nc" id="L1085">            ConsumeStatus consumeStatus = this.mQClientFactory.getConsumerStatsManager().consumeStatus(this.groupName(), sd.getTopic());</span>
<span class="nc" id="L1086">            info.getStatusTable().put(sd.getTopic(), consumeStatus);</span>
<span class="nc" id="L1087">        }</span>

<span class="fc" id="L1089">        return info;</span>
    }

    public MQClientInstance getmQClientFactory() {
<span class="fc" id="L1093">        return mQClientFactory;</span>
    }

    public void setmQClientFactory(MQClientInstance mQClientFactory) {
<span class="nc" id="L1097">        this.mQClientFactory = mQClientFactory;</span>
<span class="nc" id="L1098">    }</span>

    public ServiceState getServiceState() {
<span class="nc" id="L1101">        return serviceState;</span>
    }

    //Don't use this deprecated setter, which will be removed soon.
    @Deprecated
    public synchronized void setServiceState(ServiceState serviceState) {
<span class="nc" id="L1107">        this.serviceState = serviceState;</span>
<span class="nc" id="L1108">    }</span>

    public void adjustThreadPool() {
<span class="nc" id="L1111">        long computeAccTotal = this.computeAccumulationTotal();</span>
<span class="nc" id="L1112">        long adjustThreadPoolNumsThreshold = this.defaultMQPushConsumer.getAdjustThreadPoolNumsThreshold();</span>

<span class="nc" id="L1114">        long incThreshold = (long) (adjustThreadPoolNumsThreshold * 1.0);</span>

<span class="nc" id="L1116">        long decThreshold = (long) (adjustThreadPoolNumsThreshold * 0.8);</span>

<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (computeAccTotal &gt;= incThreshold) {</span>
<span class="nc" id="L1119">            this.consumeMessageService.incCorePoolSize();</span>
        }

<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (computeAccTotal &lt; decThreshold) {</span>
<span class="nc" id="L1123">            this.consumeMessageService.decCorePoolSize();</span>
        }
<span class="nc" id="L1125">    }</span>

    private long computeAccumulationTotal() {
<span class="nc" id="L1128">        long msgAccTotal = 0;</span>
<span class="nc" id="L1129">        ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable = this.rebalanceImpl.getProcessQueueTable();</span>
<span class="nc" id="L1130">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = processQueueTable.entrySet().iterator();</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1132">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1133">            ProcessQueue value = next.getValue();</span>
<span class="nc" id="L1134">            msgAccTotal += value.getMsgAccCnt();</span>
<span class="nc" id="L1135">        }</span>

<span class="nc" id="L1137">        return msgAccTotal;</span>
    }

    public List&lt;QueueTimeSpan&gt; queryConsumeTimeSpan(final String topic)
        throws RemotingException, MQClientException, InterruptedException, MQBrokerException {
<span class="nc" id="L1142">        List&lt;QueueTimeSpan&gt; queueTimeSpan = new ArrayList&lt;QueueTimeSpan&gt;();</span>
<span class="nc" id="L1143">        TopicRouteData routeData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, 3000);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        for (BrokerData brokerData : routeData.getBrokerDatas()) {</span>
<span class="nc" id="L1145">            String addr = brokerData.selectBrokerAddr();</span>
<span class="nc" id="L1146">            queueTimeSpan.addAll(this.mQClientFactory.getMQClientAPIImpl().queryConsumeTimeSpan(addr, topic, groupName(), 3000));</span>
<span class="nc" id="L1147">        }</span>

<span class="nc" id="L1149">        return queueTimeSpan;</span>
    }

    public void resetRetryAndNamespace(final List&lt;MessageExt&gt; msgs, String consumerGroup) {
<span class="fc" id="L1153">        final String groupTopic = MixAll.getRetryTopic(consumerGroup);</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        for (MessageExt msg : msgs) {</span>
<span class="fc" id="L1155">            String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span>
<span class="pc bpc" id="L1156" title="3 of 4 branches missed.">            if (retryTopic != null &amp;&amp; groupTopic.equals(msg.getTopic())) {</span>
<span class="nc" id="L1157">                msg.setTopic(retryTopic);</span>
            }

<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {</span>
<span class="nc" id="L1161">                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
            }
<span class="fc" id="L1163">        }</span>
<span class="fc" id="L1164">    }</span>

    public ConsumeMessageService getConsumeMessageService() {
<span class="nc" id="L1167">        return consumeMessageService;</span>
    }

    public void setConsumeMessageService(ConsumeMessageService consumeMessageService) {
<span class="fc" id="L1171">        this.consumeMessageService = consumeMessageService;</span>

<span class="fc" id="L1173">    }</span>

    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {
<span class="nc" id="L1176">        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L1177">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>