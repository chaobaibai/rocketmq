<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQProducer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.9.2</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.producer</a> &gt; <span class="el_source">DefaultMQProducer.java</span></div><h1>DefaultMQProducer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.producer;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.ExecutorService;
import org.apache.rocketmq.client.ClientConfig;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.exception.RequestTimeoutException;
import org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.client.trace.AsyncTraceDispatcher;
import org.apache.rocketmq.client.trace.TraceDispatcher;
import org.apache.rocketmq.client.trace.hook.EndTransactionTraceHookImpl;
import org.apache.rocketmq.client.trace.hook.SendMessageTraceHookImpl;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageBatch;
import org.apache.rocketmq.common.message.MessageClientIDSetter;
import org.apache.rocketmq.common.message.MessageDecoder;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageId;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.ResponseCode;
import org.apache.rocketmq.common.topic.TopicValidator;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.exception.RemotingException;

/**
 * This class is the entry point for applications intending to send messages. &lt;/p&gt;
 *
 * It's fine to tune fields which exposes getter/setter methods, but keep in mind, all of them should work well out of
 * box for most scenarios. &lt;/p&gt;
 *
 * This class aggregates various &lt;code&gt;send&lt;/code&gt; methods to deliver messages to brokers. Each of them has pros and
 * cons; you'd better understand strengths and weakness of them before actually coding. &lt;/p&gt;
 *
 * &lt;p&gt; &lt;strong&gt;Thread Safety:&lt;/strong&gt; After configuring and starting process, this class can be regarded as thread-safe
 * and used among multiple threads context. &lt;/p&gt;
 */
public class DefaultMQProducer extends ClientConfig implements MQProducer {

    /**
     * Wrapping internal implementations for virtually all methods presented in this class.
     */
    protected final transient DefaultMQProducerImpl defaultMQProducerImpl;
<span class="fc" id="L69">    private final InternalLogger log = ClientLogger.getLog();</span>
<span class="fc" id="L70">    private final Set&lt;Integer&gt; retryResponseCodes = new CopyOnWriteArraySet&lt;Integer&gt;(Arrays.asList(</span>
<span class="fc" id="L71">            ResponseCode.TOPIC_NOT_EXIST,</span>
<span class="fc" id="L72">            ResponseCode.SERVICE_NOT_AVAILABLE,</span>
<span class="fc" id="L73">            ResponseCode.SYSTEM_ERROR,</span>
<span class="fc" id="L74">            ResponseCode.NO_PERMISSION,</span>
<span class="fc" id="L75">            ResponseCode.NO_BUYER_ID,</span>
<span class="fc" id="L76">            ResponseCode.NOT_IN_CURRENT_UNIT</span>
    ));

    /**
     * Producer group conceptually aggregates all producer instances of exactly same role, which is particularly
     * important when transactional messages are involved. &lt;/p&gt;
     *
     * For non-transactional messages, it does not matter as long as it's unique per process. &lt;/p&gt;
     *
     * See {@linktourl http://rocketmq.apache.org/docs/core-concept/} for more discussion.
     */
    private String producerGroup;

    /**
     * Just for testing or demo program
     */
<span class="fc" id="L92">    private String createTopicKey = TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC;</span>

    /**
     * Number of queues to create per default topic.
     */
<span class="fc" id="L97">    private volatile int defaultTopicQueueNums = 4;</span>

    /**
     * Timeout for sending messages.
     */
<span class="fc" id="L102">    private int sendMsgTimeout = 3000;</span>

    /**
     * Compress message body threshold, namely, message body larger than 4k will be compressed on default.
     */
<span class="fc" id="L107">    private int compressMsgBodyOverHowmuch = 1024 * 4;</span>

    /**
     * Maximum number of retry to perform internally before claiming sending failure in synchronous mode. &lt;/p&gt;
     *
     * This may potentially cause message duplication which is up to application developers to resolve.
     */
<span class="fc" id="L114">    private int retryTimesWhenSendFailed = 2;</span>

    /**
     * Maximum number of retry to perform internally before claiming sending failure in asynchronous mode. &lt;/p&gt;
     *
     * This may potentially cause message duplication which is up to application developers to resolve.
     */
<span class="fc" id="L121">    private int retryTimesWhenSendAsyncFailed = 2;</span>

    /**
     * Indicate whether to retry another broker on sending failure internally.
     */
<span class="fc" id="L126">    private boolean retryAnotherBrokerWhenNotStoreOK = false;</span>

    /**
     * Maximum allowed message size in bytes.
     */
<span class="fc" id="L131">    private int maxMessageSize = 1024 * 1024 * 4; // 4M</span>

    /**
     * Interface of asynchronous transfer data
     */
<span class="fc" id="L136">    private TraceDispatcher traceDispatcher = null;</span>

    /**
     * Default constructor.
     */
    public DefaultMQProducer() {
<span class="fc" id="L142">        this(null, MixAll.DEFAULT_PRODUCER_GROUP, null);</span>
<span class="fc" id="L143">    }</span>

    /**
     * Constructor specifying the RPC hook.
     *
     * @param rpcHook RPC hook to execute per each remoting command execution.
     */
    public DefaultMQProducer(RPCHook rpcHook) {
<span class="fc" id="L151">        this(null, MixAll.DEFAULT_PRODUCER_GROUP, rpcHook);</span>
<span class="fc" id="L152">    }</span>

    /**
     * Constructor specifying producer group.
     *
     * @param producerGroup Producer group, see the name-sake field.
     */
    public DefaultMQProducer(final String producerGroup) {
<span class="fc" id="L160">        this(null, producerGroup, null);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Constructor specifying producer group.
     *
     * @param producerGroup Producer group, see the name-sake field.
     * @param rpcHook RPC hook to execute per each remoting command execution.
     * @param enableMsgTrace Switch flag instance for message trace.
     * @param customizedTraceTopic The name value of message trace topic.If you don't config,you can use the default
     * trace topic name.
     */
    public DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,
        final String customizedTraceTopic) {
<span class="nc" id="L174">        this(null, producerGroup, rpcHook, enableMsgTrace, customizedTraceTopic);</span>
<span class="nc" id="L175">    }</span>

    /**
     * Constructor specifying producer group.
     *
     * @param namespace Namespace for this MQ Producer instance.
     * @param producerGroup Producer group, see the name-sake field.
     */
    public DefaultMQProducer(final String namespace, final String producerGroup) {
<span class="nc" id="L184">        this(namespace, producerGroup, null);</span>
<span class="nc" id="L185">    }</span>

    /**
     * Constructor specifying both producer group and RPC hook.
     *
     * @param producerGroup Producer group, see the name-sake field.
     * @param rpcHook RPC hook to execute per each remoting command execution.
     */
    public DefaultMQProducer(final String producerGroup, RPCHook rpcHook) {
<span class="nc" id="L194">        this(null, producerGroup, rpcHook);</span>
<span class="nc" id="L195">    }</span>

    /**
     * Constructor specifying namespace, producer group and RPC hook.
     *
     * @param namespace Namespace for this MQ Producer instance.
     * @param producerGroup Producer group, see the name-sake field.
     * @param rpcHook RPC hook to execute per each remoting command execution.
     */
<span class="fc" id="L204">    public DefaultMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook) {</span>
<span class="fc" id="L205">        this.namespace = namespace;</span>
<span class="fc" id="L206">        this.producerGroup = producerGroup;</span>
<span class="fc" id="L207">        defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook);</span>
<span class="fc" id="L208">    }</span>

    /**
     * Constructor specifying producer group and enabled msg trace flag.
     *
     * @param producerGroup Producer group, see the name-sake field.
     * @param enableMsgTrace Switch flag instance for message trace.
     */
    public DefaultMQProducer(final String producerGroup, boolean enableMsgTrace) {
<span class="fc" id="L217">        this(null, producerGroup, null, enableMsgTrace, null);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Constructor specifying producer group, enabled msgTrace flag and customized trace topic name.
     *
     * @param producerGroup Producer group, see the name-sake field.
     * @param enableMsgTrace Switch flag instance for message trace.
     * @param customizedTraceTopic The name value of message trace topic.If you don't config,you can use the default
     * trace topic name.
     */
    public DefaultMQProducer(final String producerGroup, boolean enableMsgTrace, final String customizedTraceTopic) {
<span class="fc" id="L229">        this(null, producerGroup, null, enableMsgTrace, customizedTraceTopic);</span>
<span class="fc" id="L230">    }</span>

    /**
     * Constructor specifying namespace, producer group, RPC hook, enabled msgTrace flag and customized trace topic
     * name.
     *
     * @param namespace Namespace for this MQ Producer instance.
     * @param producerGroup Producer group, see the name-sake field.
     * @param rpcHook RPC hook to execute per each remoting command execution.
     * @param enableMsgTrace Switch flag instance for message trace.
     * @param customizedTraceTopic The name value of message trace topic.If you don't config,you can use the default
     * trace topic name.
     */
    public DefaultMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook,
<span class="fc" id="L244">        boolean enableMsgTrace, final String customizedTraceTopic) {</span>
<span class="fc" id="L245">        this.namespace = namespace;</span>
<span class="fc" id="L246">        this.producerGroup = producerGroup;</span>
<span class="fc" id="L247">        defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook);</span>
        //if client open the message trace feature
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (enableMsgTrace) {</span>
            try {
<span class="fc" id="L251">                AsyncTraceDispatcher dispatcher = new AsyncTraceDispatcher(producerGroup, TraceDispatcher.Type.PRODUCE, customizedTraceTopic, rpcHook);</span>
<span class="fc" id="L252">                dispatcher.setHostProducer(this.defaultMQProducerImpl);</span>
<span class="fc" id="L253">                traceDispatcher = dispatcher;</span>
<span class="fc" id="L254">                this.defaultMQProducerImpl.registerSendMessageHook(</span>
                    new SendMessageTraceHookImpl(traceDispatcher));
<span class="fc" id="L256">                this.defaultMQProducerImpl.registerEndTransactionHook(</span>
                    new EndTransactionTraceHookImpl(traceDispatcher));
<span class="nc" id="L258">            } catch (Throwable e) {</span>
<span class="nc" id="L259">                log.error(&quot;system mqtrace hook init failed ,maybe can't send msg trace data&quot;);</span>
<span class="fc" id="L260">            }</span>
        }
<span class="fc" id="L262">    }</span>

    @Override
    public void setUseTLS(boolean useTLS) {
<span class="fc" id="L266">        super.setUseTLS(useTLS);</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">        if (traceDispatcher != null &amp;&amp; traceDispatcher instanceof AsyncTraceDispatcher) {</span>
<span class="fc" id="L268">            ((AsyncTraceDispatcher) traceDispatcher).getTraceProducer().setUseTLS(useTLS);</span>
        }
<span class="fc" id="L270">    }</span>
    
    /**
     * Start this producer instance. &lt;/p&gt;
     *
     * &lt;strong&gt; Much internal initializing procedures are carried out to make this instance prepared, thus, it's a must
     * to invoke this method before sending or querying messages. &lt;/strong&gt; &lt;/p&gt;
     *
     * @throws MQClientException if there is any unexpected error.
     */
    @Override
    public void start() throws MQClientException {
<span class="fc" id="L282">        this.setProducerGroup(withNamespace(this.producerGroup));</span>
<span class="fc" id="L283">        this.defaultMQProducerImpl.start();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (null != traceDispatcher) {</span>
            try {
<span class="fc" id="L286">                traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());</span>
<span class="nc" id="L287">            } catch (MQClientException e) {</span>
<span class="nc" id="L288">                log.warn(&quot;trace dispatcher start failed &quot;, e);</span>
<span class="fc" id="L289">            }</span>
        }
<span class="fc" id="L291">    }</span>

    /**
     * This method shuts down this producer instance and releases related resources.
     */
    @Override
    public void shutdown() {
<span class="fc" id="L298">        this.defaultMQProducerImpl.shutdown();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (null != traceDispatcher) {</span>
<span class="fc" id="L300">            traceDispatcher.shutdown();</span>
        }
<span class="fc" id="L302">    }</span>

    /**
     * Fetch message queues of topic &lt;code&gt;topic&lt;/code&gt;, to which we may send/publish messages.
     *
     * @param topic Topic to fetch.
     * @return List of message queues readily to send messages to
     * @throws MQClientException if there is any client error.
     */
    @Override
    public List&lt;MessageQueue&gt; fetchPublishMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L313">        return this.defaultMQProducerImpl.fetchPublishMessageQueues(withNamespace(topic));</span>
    }

    /**
     * Send message in synchronous mode. This method returns only when the sending procedure totally completes. &lt;/p&gt;
     *
     * &lt;strong&gt;Warn:&lt;/strong&gt; this method has internal retry-mechanism, that is, internal implementation will retry
     * {@link #retryTimesWhenSendFailed} times before claiming failure. As a result, multiple messages may potentially
     * delivered to broker(s). It's up to the application developers to resolve potential duplication issue.
     *
     * @param msg Message to send.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(
        Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L334">        Validators.checkMessage(msg, this);</span>
<span class="fc" id="L335">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L336">        return this.defaultMQProducerImpl.send(msg);</span>
    }

    /**
     * Same to {@link #send(Message)} with send timeout specified in addition.
     *
     * @param msg Message to send.
     * @param timeout send timeout.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(Message msg,
        long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L354">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L355">        return this.defaultMQProducerImpl.send(msg, timeout);</span>
    }

    /**
     * Send message to broker asynchronously. &lt;/p&gt;
     *
     * This method returns immediately. On sending completion, &lt;code&gt;sendCallback&lt;/code&gt; will be executed. &lt;/p&gt;
     *
     * Similar to {@link #send(Message)}, internal implementation would potentially retry up to {@link
     * #retryTimesWhenSendAsyncFailed} times before claiming sending failure, which may yield message duplication and
     * application developers are the one to resolve this potential issue.
     *
     * @param msg Message to send.
     * @param sendCallback Callback to execute on sending completed, either successful or unsuccessful.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg,
        SendCallback sendCallback) throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L376">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L377">        this.defaultMQProducerImpl.send(msg, sendCallback);</span>
<span class="fc" id="L378">    }</span>

    /**
     * Same to {@link #send(Message, SendCallback)} with send timeout specified in addition.
     *
     * @param msg message to send.
     * @param sendCallback Callback to execute.
     * @param timeout send timeout.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg, SendCallback sendCallback, long timeout)
        throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L393">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L394">        this.defaultMQProducerImpl.send(msg, sendCallback, timeout);</span>
<span class="fc" id="L395">    }</span>

    /**
     * Similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/User_Datagram_Protocol&quot;&gt;UDP&lt;/a&gt;, this method won't wait for
     * acknowledgement from broker before return. Obviously, it has maximums throughput yet potentials of message loss.
     *
     * @param msg Message to send.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void sendOneway(Message msg) throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L408">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L409">        this.defaultMQProducerImpl.sendOneway(msg);</span>
<span class="nc" id="L410">    }</span>

    /**
     * Same to {@link #send(Message)} with target message queue specified in addition.
     *
     * @param msg Message to send.
     * @param mq Target message queue.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(Message msg, MessageQueue mq)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L427">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L428">        return this.defaultMQProducerImpl.send(msg, queueWithNamespace(mq));</span>
    }

    /**
     * Same to {@link #send(Message)} with target message queue and send timeout specified.
     *
     * @param msg Message to send.
     * @param mq Target message queue.
     * @param timeout send timeout.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(Message msg, MessageQueue mq, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L447">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L448">        return this.defaultMQProducerImpl.send(msg, queueWithNamespace(mq), timeout);</span>
    }

    /**
     * Same to {@link #send(Message, SendCallback)} with target message queue specified.
     *
     * @param msg Message to send.
     * @param mq Target message queue.
     * @param sendCallback Callback to execute on sending completed, either successful or unsuccessful.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg, MessageQueue mq, SendCallback sendCallback)
        throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L464">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L465">        this.defaultMQProducerImpl.send(msg, queueWithNamespace(mq), sendCallback);</span>
<span class="fc" id="L466">    }</span>

    /**
     * Same to {@link #send(Message, SendCallback)} with target message queue and send timeout specified.
     *
     * @param msg Message to send.
     * @param mq Target message queue.
     * @param sendCallback Callback to execute on sending completed, either successful or unsuccessful.
     * @param timeout Send timeout.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg, MessageQueue mq, SendCallback sendCallback, long timeout)
        throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L482">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L483">        this.defaultMQProducerImpl.send(msg, queueWithNamespace(mq), sendCallback, timeout);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Same to {@link #sendOneway(Message)} with target message queue specified.
     *
     * @param msg Message to send.
     * @param mq Target message queue.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void sendOneway(Message msg,
        MessageQueue mq) throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L498">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L499">        this.defaultMQProducerImpl.sendOneway(msg, queueWithNamespace(mq));</span>
<span class="nc" id="L500">    }</span>

    /**
     * Same to {@link #send(Message)} with message queue selector specified.
     *
     * @param msg Message to send.
     * @param selector Message queue selector, through which we get target message queue to deliver message to.
     * @param arg Argument to work along with message queue selector.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(Message msg, MessageQueueSelector selector, Object arg)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L518">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L519">        return this.defaultMQProducerImpl.send(msg, selector, arg);</span>
    }

    /**
     * Same to {@link #send(Message, MessageQueueSelector, Object)} with send timeout specified.
     *
     * @param msg Message to send.
     * @param selector Message queue selector, through which we get target message queue to deliver message to.
     * @param arg Argument to work along with message queue selector.
     * @param timeout Send timeout.
     * @return {@link SendResult} instance to inform senders details of the deliverable, say Message ID of the message,
     * {@link SendStatus} indicating broker storage/replication status, message queue sent to, etc.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any error with broker.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public SendResult send(Message msg, MessageQueueSelector selector, Object arg, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L539">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L540">        return this.defaultMQProducerImpl.send(msg, selector, arg, timeout);</span>
    }

    /**
     * Same to {@link #send(Message, SendCallback)} with message queue selector specified.
     *
     * @param msg Message to send.
     * @param selector Message selector through which to get target message queue.
     * @param arg Argument used along with message queue selector.
     * @param sendCallback callback to execute on sending completion.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback)
        throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L557">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L558">        this.defaultMQProducerImpl.send(msg, selector, arg, sendCallback);</span>
<span class="fc" id="L559">    }</span>

    /**
     * Same to {@link #send(Message, MessageQueueSelector, Object, SendCallback)} with timeout specified.
     *
     * @param msg Message to send.
     * @param selector Message selector through which to get target message queue.
     * @param arg Argument used along with message queue selector.
     * @param sendCallback callback to execute on sending completion.
     * @param timeout Send timeout.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback, long timeout)
        throws MQClientException, RemotingException, InterruptedException {
<span class="fc" id="L576">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L577">        this.defaultMQProducerImpl.send(msg, selector, arg, sendCallback, timeout);</span>
<span class="fc" id="L578">    }</span>

    /**
     * Send request message in synchronous mode. This method returns only when the consumer consume the request message and reply a message. &lt;/p&gt;
     *
     * &lt;strong&gt;Warn:&lt;/strong&gt; this method has internal retry-mechanism, that is, internal implementation will retry
     * {@link #retryTimesWhenSendFailed} times before claiming failure. As a result, multiple messages may potentially
     * delivered to broker(s). It's up to the application developers to resolve potential duplication issue.
     *
     * @param msg request message to send
     * @param timeout request timeout
     * @return reply message
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any broker error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws RequestTimeoutException if request timeout.
     */
    @Override
    public Message request(final Message msg, final long timeout) throws RequestTimeoutException, MQClientException,
        RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L599">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L600">        return this.defaultMQProducerImpl.request(msg, timeout);</span>
    }

    /**
     * Request asynchronously. &lt;/p&gt;
     * This method returns immediately. On receiving reply message, &lt;code&gt;requestCallback&lt;/code&gt; will be executed. &lt;/p&gt;
     *
     * Similar to {@link #request(Message, long)}, internal implementation would potentially retry up to {@link
     * #retryTimesWhenSendAsyncFailed} times before claiming sending failure, which may yield message duplication and
     * application developers are the one to resolve this potential issue.
     *
     * @param msg request message to send
     * @param requestCallback callback to execute on request completion.
     * @param timeout request timeout
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws MQBrokerException if there is any broker error.
     */
    @Override
    public void request(final Message msg, final RequestCallback requestCallback, final long timeout)
        throws MQClientException, RemotingException, InterruptedException, MQBrokerException {
<span class="fc" id="L622">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="fc" id="L623">        this.defaultMQProducerImpl.request(msg, requestCallback, timeout);</span>
<span class="fc" id="L624">    }</span>

    /**
     * Same to {@link #request(Message, long)}  with message queue selector specified.
     *
     * @param msg request message to send
     * @param selector message queue selector, through which we get target message queue to deliver message to.
     * @param arg argument to work along with message queue selector.
     * @param timeout timeout of request.
     * @return reply message
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any broker error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws RequestTimeoutException if request timeout.
     */
    @Override
    public Message request(final Message msg, final MessageQueueSelector selector, final Object arg,
        final long timeout) throws MQClientException, RemotingException, MQBrokerException,
        InterruptedException, RequestTimeoutException {
<span class="nc" id="L644">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L645">        return this.defaultMQProducerImpl.request(msg, selector, arg, timeout);</span>
    }

    /**
     * Same to {@link #request(Message, RequestCallback, long)} with target message selector specified.
     *
     * @param msg requst message to send
     * @param selector message queue selector, through which we get target message queue to deliver message to.
     * @param arg argument to work along with message queue selector.
     * @param requestCallback callback to execute on request completion.
     * @param timeout timeout of request.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws MQBrokerException if there is any broker error.
     */
    @Override
    public void request(final Message msg, final MessageQueueSelector selector, final Object arg,
        final RequestCallback requestCallback, final long timeout) throws MQClientException, RemotingException,
        InterruptedException, MQBrokerException {
<span class="nc" id="L665">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L666">        this.defaultMQProducerImpl.request(msg, selector, arg, requestCallback, timeout);</span>
<span class="nc" id="L667">    }</span>

    /**
     * Same to {@link #request(Message, long)}  with target message queue specified in addition.
     *
     * @param msg request message to send
     * @param mq target message queue.
     * @param timeout request timeout
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws MQBrokerException if there is any broker error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws RequestTimeoutException if request timeout.
     */
    @Override
    public Message request(final Message msg, final MessageQueue mq, final long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException, RequestTimeoutException {
<span class="nc" id="L684">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L685">        return this.defaultMQProducerImpl.request(msg, mq, timeout);</span>
    }

    /**
     * Same to {@link #request(Message, RequestCallback, long)} with target message queue specified.
     *
     * @param msg request message to send
     * @param mq target message queue.
     * @param requestCallback callback to execute on request completion.
     * @param timeout timeout of request.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the thread is interrupted.
     * @throws MQBrokerException if there is any broker error.
     */
    @Override
    public void request(final Message msg, final MessageQueue mq, final RequestCallback requestCallback, long timeout)
        throws MQClientException, RemotingException, InterruptedException, MQBrokerException {
<span class="nc" id="L703">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L704">        this.defaultMQProducerImpl.request(msg, mq, requestCallback, timeout);</span>
<span class="nc" id="L705">    }</span>

    /**
     * Same to {@link #sendOneway(Message)} with message queue selector specified.
     *
     * @param msg Message to send.
     * @param selector Message queue selector, through which to determine target message queue to deliver message
     * @param arg Argument used along with message queue selector.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Override
    public void sendOneway(Message msg, MessageQueueSelector selector, Object arg)
        throws MQClientException, RemotingException, InterruptedException {
<span class="nc" id="L720">        msg.setTopic(withNamespace(msg.getTopic()));</span>
<span class="nc" id="L721">        this.defaultMQProducerImpl.sendOneway(msg, selector, arg);</span>
<span class="nc" id="L722">    }</span>

    /**
     * This method is to send transactional messages.
     *
     * @param msg Transactional message to send.
     * @param tranExecuter local transaction executor.
     * @param arg Argument used along with local transaction executor.
     * @return Transaction result.
     * @throws MQClientException if there is any client error.
     */
    @Override
    public TransactionSendResult sendMessageInTransaction(Message msg, LocalTransactionExecuter tranExecuter,
        final Object arg)
        throws MQClientException {
<span class="nc" id="L737">        throw new RuntimeException(&quot;sendMessageInTransaction not implement, please use TransactionMQProducer class&quot;);</span>
    }

    /**
     * This method is used to send transactional messages.
     *
     * @param msg Transactional message to send.
     * @param arg Argument used along with local transaction executor.
     * @return Transaction result.
     * @throws MQClientException
     */
    @Override
    public TransactionSendResult sendMessageInTransaction(Message msg,
        Object arg) throws MQClientException {
<span class="nc" id="L751">        throw new RuntimeException(&quot;sendMessageInTransaction not implement, please use TransactionMQProducer class&quot;);</span>
    }

    /**
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param key accesskey
     * @param newTopic topic name
     * @param queueNum topic's queue number
     * @throws MQClientException if there is any client error.
     */
    @Deprecated
    @Override
    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L765">        createTopic(key, withNamespace(newTopic), queueNum, 0);</span>
<span class="nc" id="L766">    }</span>

    /**
     * Create a topic on broker. This method will be removed in a certain version after April 5, 2020, so please do not
     * use this method.
     *
     * @param key accesskey
     * @param newTopic topic name
     * @param queueNum topic's queue number
     * @param topicSysFlag topic system flag
     * @throws MQClientException if there is any client error.
     */
    @Deprecated
    @Override
    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L781">        this.defaultMQProducerImpl.createTopic(key, withNamespace(newTopic), queueNum, topicSysFlag);</span>
<span class="nc" id="L782">    }</span>

    /**
     * Search consume queue offset of the given time stamp.
     *
     * @param mq Instance of MessageQueue
     * @param timestamp from when in milliseconds.
     * @return Consume queue offset.
     * @throws MQClientException if there is any client error.
     */
    @Override
    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L794">        return this.defaultMQProducerImpl.searchOffset(queueWithNamespace(mq), timestamp);</span>
    }

    /**
     * Query maximum offset of the given message queue.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param mq Instance of MessageQueue
     * @return maximum offset of the given consume queue.
     * @throws MQClientException if there is any client error.
     */
    @Deprecated
    @Override
    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L809">        return this.defaultMQProducerImpl.maxOffset(queueWithNamespace(mq));</span>
    }

    /**
     * Query minimum offset of the given message queue.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param mq Instance of MessageQueue
     * @return minimum offset of the given message queue.
     * @throws MQClientException if there is any client error.
     */
    @Deprecated
    @Override
    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L824">        return this.defaultMQProducerImpl.minOffset(queueWithNamespace(mq));</span>
    }

    /**
     * Query earliest message store time.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param mq Instance of MessageQueue
     * @return earliest message store time.
     * @throws MQClientException if there is any client error.
     */
    @Deprecated
    @Override
    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L839">        return this.defaultMQProducerImpl.earliestMsgStoreTime(queueWithNamespace(mq));</span>
    }

    /**
     * Query message of the given offset message ID.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param offsetMsgId message id
     * @return Message specified.
     * @throws MQBrokerException if there is any broker error.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Deprecated
    @Override
    public MessageExt viewMessage(
        String offsetMsgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L858">        return this.defaultMQProducerImpl.viewMessage(offsetMsgId);</span>
    }

    /**
     * Query message by key.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param topic message topic
     * @param key message key index word
     * @param maxNum max message number
     * @param begin from when
     * @param end to when
     * @return QueryResult instance contains matched messages.
     * @throws MQClientException if there is any client error.
     * @throws InterruptedException if the thread is interrupted.
     */
    @Deprecated
    @Override
    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L879">        return this.defaultMQProducerImpl.queryMessage(withNamespace(topic), key, maxNum, begin, end);</span>
    }

    /**
     * Query message of the given message ID.
     *
     * This method will be removed in a certain version after April 5, 2020, so please do not use this method.
     *
     * @param topic Topic
     * @param msgId Message ID
     * @return Message specified.
     * @throws MQBrokerException if there is any broker error.
     * @throws MQClientException if there is any client error.
     * @throws RemotingException if there is any network-tier error.
     * @throws InterruptedException if the sending thread is interrupted.
     */
    @Deprecated
    @Override
    public MessageExt viewMessage(String topic,
        String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="nc" id="L900">            MessageId oldMsgId = MessageDecoder.decodeMessageId(msgId);</span>
<span class="nc" id="L901">            return this.viewMessage(msgId);</span>
<span class="nc" id="L902">        } catch (Exception e) {</span>
        }
<span class="nc" id="L904">        return this.defaultMQProducerImpl.queryMessageByUniqKey(withNamespace(topic), msgId);</span>
    }

    @Override
    public SendResult send(
        Collection&lt;Message&gt; msgs) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L910">        return this.defaultMQProducerImpl.send(batch(msgs));</span>
    }

    @Override
    public SendResult send(Collection&lt;Message&gt; msgs,
        long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L916">        return this.defaultMQProducerImpl.send(batch(msgs), timeout);</span>
    }

    @Override
    public SendResult send(Collection&lt;Message&gt; msgs,
        MessageQueue messageQueue) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L922">        return this.defaultMQProducerImpl.send(batch(msgs), messageQueue);</span>
    }

    @Override
    public SendResult send(Collection&lt;Message&gt; msgs, MessageQueue messageQueue,
        long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="nc" id="L928">        return this.defaultMQProducerImpl.send(batch(msgs), messageQueue, timeout);</span>
    }

    @Override
    public void send(Collection&lt;Message&gt; msgs, SendCallback sendCallback) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L933">        this.defaultMQProducerImpl.send(batch(msgs), sendCallback);</span>
<span class="fc" id="L934">    }</span>

    @Override
    public void send(Collection&lt;Message&gt; msgs, SendCallback sendCallback,
        long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L939">        this.defaultMQProducerImpl.send(batch(msgs), sendCallback, timeout);</span>
<span class="fc" id="L940">    }</span>

    @Override
    public void send(Collection&lt;Message&gt; msgs, MessageQueue mq,
        SendCallback sendCallback) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L945">        this.defaultMQProducerImpl.send(batch(msgs), queueWithNamespace(mq), sendCallback);</span>
<span class="fc" id="L946">    }</span>

    @Override
    public void send(Collection&lt;Message&gt; msgs, MessageQueue mq,
        SendCallback sendCallback, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L951">        this.defaultMQProducerImpl.send(batch(msgs), queueWithNamespace(mq), sendCallback, timeout);</span>
<span class="fc" id="L952">    }</span>

    /**
     * Sets an Executor to be used for executing callback methods. If the Executor is not set, {@link
     * NettyRemotingClient#publicExecutor} will be used.
     *
     * @param callbackExecutor the instance of Executor
     */
    public void setCallbackExecutor(final ExecutorService callbackExecutor) {
<span class="fc" id="L961">        this.defaultMQProducerImpl.setCallbackExecutor(callbackExecutor);</span>
<span class="fc" id="L962">    }</span>

    /**
     * Sets an Executor to be used for executing asynchronous send. If the Executor is not set, {@link
     * DefaultMQProducerImpl#defaultAsyncSenderExecutor} will be used.
     *
     * @param asyncSenderExecutor the instance of Executor
     */
    public void setAsyncSenderExecutor(final ExecutorService asyncSenderExecutor) {
<span class="nc" id="L971">        this.defaultMQProducerImpl.setAsyncSenderExecutor(asyncSenderExecutor);</span>
<span class="nc" id="L972">    }</span>

    /**
     * Add response code for retrying.
     *
     * @param responseCode response code, {@link ResponseCode}
     */
    public void addRetryResponseCode(int responseCode) {
<span class="nc" id="L980">        this.retryResponseCodes.add(responseCode);</span>
<span class="nc" id="L981">    }</span>

    private MessageBatch batch(Collection&lt;Message&gt; msgs) throws MQClientException {
        MessageBatch msgBatch;
        try {
<span class="fc" id="L986">            msgBatch = MessageBatch.generateFromList(msgs);</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">            for (Message message : msgBatch) {</span>
<span class="fc" id="L988">                Validators.checkMessage(message, this);</span>
<span class="fc" id="L989">                MessageClientIDSetter.setUniqID(message);</span>
<span class="fc" id="L990">                message.setTopic(withNamespace(message.getTopic()));</span>
<span class="fc" id="L991">            }</span>
<span class="fc" id="L992">            msgBatch.setBody(msgBatch.encode());</span>
<span class="nc" id="L993">        } catch (Exception e) {</span>
<span class="nc" id="L994">            throw new MQClientException(&quot;Failed to initiate the MessageBatch&quot;, e);</span>
<span class="fc" id="L995">        }</span>
<span class="fc" id="L996">        msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</span>
<span class="fc" id="L997">        return msgBatch;</span>
    }

    public String getProducerGroup() {
<span class="fc" id="L1001">        return producerGroup;</span>
    }

    public void setProducerGroup(String producerGroup) {
<span class="fc" id="L1005">        this.producerGroup = producerGroup;</span>
<span class="fc" id="L1006">    }</span>

    public String getCreateTopicKey() {
<span class="fc" id="L1009">        return createTopicKey;</span>
    }

    public void setCreateTopicKey(String createTopicKey) {
<span class="nc" id="L1013">        this.createTopicKey = createTopicKey;</span>
<span class="nc" id="L1014">    }</span>

    public int getSendMsgTimeout() {
<span class="fc" id="L1017">        return sendMsgTimeout;</span>
    }

    public void setSendMsgTimeout(int sendMsgTimeout) {
<span class="fc" id="L1021">        this.sendMsgTimeout = sendMsgTimeout;</span>
<span class="fc" id="L1022">    }</span>

    public int getCompressMsgBodyOverHowmuch() {
<span class="fc" id="L1025">        return compressMsgBodyOverHowmuch;</span>
    }

    public void setCompressMsgBodyOverHowmuch(int compressMsgBodyOverHowmuch) {
<span class="fc" id="L1029">        this.compressMsgBodyOverHowmuch = compressMsgBodyOverHowmuch;</span>
<span class="fc" id="L1030">    }</span>

    @Deprecated
    public DefaultMQProducerImpl getDefaultMQProducerImpl() {
<span class="fc" id="L1034">        return defaultMQProducerImpl;</span>
    }

    public boolean isRetryAnotherBrokerWhenNotStoreOK() {
<span class="nc" id="L1038">        return retryAnotherBrokerWhenNotStoreOK;</span>
    }

    public void setRetryAnotherBrokerWhenNotStoreOK(boolean retryAnotherBrokerWhenNotStoreOK) {
<span class="nc" id="L1042">        this.retryAnotherBrokerWhenNotStoreOK = retryAnotherBrokerWhenNotStoreOK;</span>
<span class="nc" id="L1043">    }</span>

    public int getMaxMessageSize() {
<span class="fc" id="L1046">        return maxMessageSize;</span>
    }

    public void setMaxMessageSize(int maxMessageSize) {
<span class="fc" id="L1050">        this.maxMessageSize = maxMessageSize;</span>
<span class="fc" id="L1051">    }</span>

    public int getDefaultTopicQueueNums() {
<span class="fc" id="L1054">        return defaultTopicQueueNums;</span>
    }

    public void setDefaultTopicQueueNums(int defaultTopicQueueNums) {
<span class="nc" id="L1058">        this.defaultTopicQueueNums = defaultTopicQueueNums;</span>
<span class="nc" id="L1059">    }</span>

    public int getRetryTimesWhenSendFailed() {
<span class="fc" id="L1062">        return retryTimesWhenSendFailed;</span>
    }

    public void setRetryTimesWhenSendFailed(int retryTimesWhenSendFailed) {
<span class="nc" id="L1066">        this.retryTimesWhenSendFailed = retryTimesWhenSendFailed;</span>
<span class="nc" id="L1067">    }</span>

    public boolean isSendMessageWithVIPChannel() {
<span class="fc" id="L1070">        return isVipChannelEnabled();</span>
    }

    public void setSendMessageWithVIPChannel(final boolean sendMessageWithVIPChannel) {
<span class="nc" id="L1074">        this.setVipChannelEnabled(sendMessageWithVIPChannel);</span>
<span class="nc" id="L1075">    }</span>

    public long[] getNotAvailableDuration() {
<span class="nc" id="L1078">        return this.defaultMQProducerImpl.getNotAvailableDuration();</span>
    }

    public void setNotAvailableDuration(final long[] notAvailableDuration) {
<span class="nc" id="L1082">        this.defaultMQProducerImpl.setNotAvailableDuration(notAvailableDuration);</span>
<span class="nc" id="L1083">    }</span>

    public long[] getLatencyMax() {
<span class="nc" id="L1086">        return this.defaultMQProducerImpl.getLatencyMax();</span>
    }

    public void setLatencyMax(final long[] latencyMax) {
<span class="nc" id="L1090">        this.defaultMQProducerImpl.setLatencyMax(latencyMax);</span>
<span class="nc" id="L1091">    }</span>

    public boolean isSendLatencyFaultEnable() {
<span class="nc" id="L1094">        return this.defaultMQProducerImpl.isSendLatencyFaultEnable();</span>
    }

    public void setSendLatencyFaultEnable(final boolean sendLatencyFaultEnable) {
<span class="nc" id="L1098">        this.defaultMQProducerImpl.setSendLatencyFaultEnable(sendLatencyFaultEnable);</span>
<span class="nc" id="L1099">    }</span>

    public int getRetryTimesWhenSendAsyncFailed() {
<span class="fc" id="L1102">        return retryTimesWhenSendAsyncFailed;</span>
    }

    public void setRetryTimesWhenSendAsyncFailed(final int retryTimesWhenSendAsyncFailed) {
<span class="nc" id="L1106">        this.retryTimesWhenSendAsyncFailed = retryTimesWhenSendAsyncFailed;</span>
<span class="nc" id="L1107">    }</span>

    public TraceDispatcher getTraceDispatcher() {
<span class="fc" id="L1110">        return traceDispatcher;</span>
    }

    public Set&lt;Integer&gt; getRetryResponseCodes() {
<span class="nc" id="L1114">        return retryResponseCodes;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>